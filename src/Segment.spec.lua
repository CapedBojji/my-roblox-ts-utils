-- Compiled with roblox-ts v2.3.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
--/ <reference types="@rbxts/testez/globals" />
local Segment = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Segment").default
local Point2D = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "Point").default
return function()
	describe("Segment methods", function()
		describe("Segment.getSlope", function()
			it("calculates positive slope correctly", function()
				local segment = Segment.new(Point2D.new(1, 1), Point2D.new(2, 3))
				local slope = segment:getSlope()
				expect(slope).to.equal(2)
			end)
			it("calculates negative slope correctly", function()
				local segment = Segment.new(Point2D.new(1, 3), Point2D.new(2, 1))
				local slope = segment:getSlope()
				expect(slope).to.equal(-2)
			end)
			it("returns 0 for horizontal lines", function()
				local segment = Segment.new(Point2D.new(1, 1), Point2D.new(3, 1))
				local slope = segment:getSlope()
				expect(slope).to.equal(0)
			end)
			it("returns undefined for vertical lines", function()
				local segment = Segment.new(Point2D.new(1, 1), Point2D.new(1, 3))
				local slope = segment:getSlope()
				expect(slope).never.to.be.ok()
			end)
			it("returns undefined for identical points", function()
				local segment = Segment.new(Point2D.new(1, 1), Point2D.new(1, 1))
				local slope = segment:getSlope()
				expect(slope).never.to.be.ok()
			end)
		end)
		-- Test for isVertical
		describe("isVertical", function()
			it("should return true for vertical lines", function()
				local segment = Segment.new(Point2D.new(1, 1), Point2D.new(1, 3))
				expect(segment:isVertical()).to.equal(true)
			end)
			it("should return false for non-vertical lines", function()
				local segment = Segment.new(Point2D.new(1, 1), Point2D.new(2, 3))
				expect(segment:isVertical()).to.equal(false)
			end)
		end)
		-- Test for getLength
		describe("getLength", function()
			it("calculates length correctly", function()
				local segment = Segment.new(Point2D.new(0, 0), Point2D.new(3, 4))
				expect(segment:getLength()).to.be:near(5, 1e-6)
			end)
		end)
		-- Test for isHorizontal
		describe("isHorizontal", function()
			it("should return true for horizontal lines", function()
				local segment = Segment.new(Point2D.new(1, 1), Point2D.new(3, 1))
				expect(segment:isHorizontal()).to.equal(true)
			end)
			it("should return false for non-horizontal lines", function()
				local segment = Segment.new(Point2D.new(1, 1), Point2D.new(1, 3))
				expect(segment:isHorizontal()).to.equal(false)
			end)
		end)
		-- Test for isParallelTo
		describe("isParallelTo", function()
			it("should return true for parallel segments", function()
				local segment1 = Segment.new(Point2D.new(1, 1), Point2D.new(2, 2))
				local segment2 = Segment.new(Point2D.new(2, 2), Point2D.new(3, 3))
				expect(segment1:isParallelTo(segment2)).to.equal(true)
			end)
			it("should return false for non-parallel segments", function()
				local segment1 = Segment.new(Point2D.new(1, 1), Point2D.new(2, 2))
				local segment2 = Segment.new(Point2D.new(1, 1), Point2D.new(2, 3))
				expect(segment1:isParallelTo(segment2)).to.equal(false)
			end)
			it("should return true for vertical parallel segments", function()
				local segment1 = Segment.new(Point2D.new(1, 1), Point2D.new(1, 3))
				local segment2 = Segment.new(Point2D.new(2, 2), Point2D.new(2, 4))
				expect(segment1:isParallelTo(segment2)).to.equal(true)
			end)
			it("should return true for horizontal parallel segments", function()
				local segment1 = Segment.new(Point2D.new(1, 1), Point2D.new(3, 1))
				local segment2 = Segment.new(Point2D.new(2, 1), Point2D.new(4, 1))
				expect(segment1:isParallelTo(segment2)).to.equal(true)
			end)
		end)
		-- X-Intercept and Y-Intercept Tests
		describe("xIntercept and yIntercept methods", function()
			it("calculates x-intercept correctly", function()
				local segment = Segment.new(Point2D.new(0, 2), Point2D.new(2, 0))
				expect(segment:xIntercept()).to.equal(2)
			end)
			it("calculates y-intercept correctly", function()
				local segment = Segment.new(Point2D.new(0, 2), Point2D.new(2, 0))
				expect(segment:yIntercept()).to.equal(2)
			end)
			it("returns undefined for y-intercept of a vertical line", function()
				local segment = Segment.new(Point2D.new(1, 1), Point2D.new(1, 3))
				expect(segment:yIntercept()).never.to.be.ok()
			end)
			it("returns undefined for x-intercept of a horizontal line", function()
				local segment = Segment.new(Point2D.new(1, 1), Point2D.new(3, 1))
				expect(segment:xIntercept()).never.to.be.ok()
			end)
		end)
		-- Equals Tests
		describe("equals method", function()
			it("recognizes two identical segments as equal", function()
				local segment1 = Segment.new(Point2D.new(1, 1), Point2D.new(2, 2))
				local segment2 = Segment.new(Point2D.new(1, 1), Point2D.new(2, 2))
				expect(segment1:equals(segment2)).to.equal(true)
			end)
			it("recognizes two different segments as not equal", function()
				local segment1 = Segment.new(Point2D.new(1, 1), Point2D.new(2, 2))
				local segment2 = Segment.new(Point2D.new(1, 2), Point2D.new(2, 3))
				expect(segment1:equals(segment2)).to.equal(false)
			end)
		end)
		-- isCollinearWith Tests
		describe("isCollinearWith method", function()
			it("identifies collinear segments", function()
				local segment1 = Segment.new(Point2D.new(0, 0), Point2D.new(1, 1))
				local segment2 = Segment.new(Point2D.new(2, 2), Point2D.new(3, 3))
				expect(segment1:isCollinearWith(segment2)).to.equal(true)
			end)
			it("identifies non-collinear segments", function()
				local segment1 = Segment.new(Point2D.new(0, 0), Point2D.new(1, 1))
				local segment2 = Segment.new(Point2D.new(1, 0), Point2D.new(2, 2))
				expect(segment1:isCollinearWith(segment2)).to.equal(false)
			end)
		end)
		-- containsPoint Tests
		describe("containsPoint method", function()
			it("confirms a point on the segment", function()
				local segment = Segment.new(Point2D.new(0, 0), Point2D.new(2, 2))
				local point = Point2D.new(1, 1)
				expect(segment:containsPoint(point)).to.equal(true)
			end)
			it("rejects a point not on the segment", function()
				local segment = Segment.new(Point2D.new(0, 0), Point2D.new(2, 2))
				local point = Point2D.new(2, 1)
				expect(segment:containsPoint(point)).to.equal(false)
			end)
			it("confirms a point on a horizontal segment", function()
				local segment = Segment.new(Point2D.new(0, 0), Point2D.new(2, 0))
				local point = Point2D.new(1, 0)
				expect(segment:containsPoint(point)).to.equal(true)
			end)
			it("confirms a point on a vertical segment", function()
				local segment = Segment.new(Point2D.new(0, 0), Point2D.new(0, 2))
				local point = Point2D.new(0, 1)
				expect(segment:containsPoint(point)).to.equal(true)
			end)
		end)
		-- getIntersection Method Tests
		describe("getIntersection method scenarios", function()
			it("returns the correct intersection point for segments that intersect normally", function()
				local segment1 = Segment.new(Point2D.new(0, 0), Point2D.new(2, 2))
				local segment2 = Segment.new(Point2D.new(0, 2), Point2D.new(2, 0))
				local intersection = segment1:getIntersection(segment2)
				local _result = intersection
				if _result ~= nil then
					_result = _result:equals(Point2D.new(1, 1))
				end
				expect(_result).to.equal(true)
			end)
			it("returns undefined for parallel segments that do not intersect", function()
				local segment1 = Segment.new(Point2D.new(0, 0), Point2D.new(2, 2))
				local segment2 = Segment.new(Point2D.new(0, 1), Point2D.new(2, 3))
				local intersection = segment1:getIntersection(segment2)
				expect(intersection).never.to.be.ok()
			end)
			it("returns the overlapping segment for collinear segments that overlap", function()
				-- Assuming getIntersection returns a Segment for overlapping collinear segments
				local segment1 = Segment.new(Point2D.new(0, 0), Point2D.new(2, 2))
				local segment2 = Segment.new(Point2D.new(1, 1), Point2D.new(3, 3))
				local intersection = segment1:getIntersection(segment2)
				-- Validate that the intersection is a segment from (1, 1) to (2, 2)
				local expectedStart = Point2D.new(1, 1)
				local expectedEnd = Point2D.new(2, 2)
				expect((intersection:getPoints()[1]:equals(expectedStart) and intersection:getPoints()[2]:equals(expectedEnd)) or (intersection:getPoints()[1]:equals(expectedEnd) and intersection:getPoints()[2]:equals(expectedStart))).to.equal(true)
			end)
			it("returns undefined for collinear segments that do not overlap", function()
				local segment1 = Segment.new(Point2D.new(0, 0), Point2D.new(1, 1))
				local segment2 = Segment.new(Point2D.new(2, 2), Point2D.new(3, 3))
				local intersection = segment1:getIntersection(segment2)
				expect(intersection).never.to.be.ok()
			end)
			it("returns the correct intersection point for segments that are perpendicular", function()
				local segment1 = Segment.new(Point2D.new(0, 1), Point2D.new(2, 1))
				local segment2 = Segment.new(Point2D.new(1, 0), Point2D.new(1, 2))
				local intersection = segment1:getIntersection(segment2)
				local _result = intersection
				if _result ~= nil then
					_result = _result:equals(Point2D.new(1, 1))
				end
				expect(_result).to.equal(true)
			end)
			it("handles intersection when one segment is vertical", function()
				local segment1 = Segment.new(Point2D.new(1, 0), Point2D.new(1, 2))
				local segment2 = Segment.new(Point2D.new(0, 1), Point2D.new(2, 1))
				local intersection = segment1:getIntersection(segment2)
				local _result = intersection
				if _result ~= nil then
					_result = _result:equals(Point2D.new(1, 1))
				end
				expect(_result).to.equal(true)
			end)
			it("handles intersection when one segment is horizontal", function()
				local segment1 = Segment.new(Point2D.new(0, 1), Point2D.new(2, 1))
				local segment2 = Segment.new(Point2D.new(1, 0), Point2D.new(1, 2))
				local intersection = segment1:getIntersection(segment2)
				local _result = intersection
				if _result ~= nil then
					_result = _result:equals(Point2D.new(1, 1))
				end
				expect(_result).to.equal(true)
			end)
			it("returns undefined for segments that do not intersect with one being vertical", function()
				local segment1 = Segment.new(Point2D.new(1, 0), Point2D.new(1, 2))
				local segment2 = Segment.new(Point2D.new(2, 0), Point2D.new(2, 3))
				local intersection = segment1:getIntersection(segment2)
				expect(intersection).never.to.be.ok()
			end)
			it("returns undefined for segments that do not intersect with one being horizontal", function()
				local segment1 = Segment.new(Point2D.new(0, 1), Point2D.new(2, 1))
				local segment2 = Segment.new(Point2D.new(0, 2), Point2D.new(3, 2))
				local intersection = segment1:getIntersection(segment2)
				expect(intersection).never.to.be.ok()
			end)
		end)
	end)
end
